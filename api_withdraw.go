
/*
 * INLOCK API
 *
 * This is the documentation of the INLOCK API.  # Responses Endpoints return HTTP status code 200 in case of successful operation. The following response body format is used:  {   \"result\": {\"status\": \"ok\", \"`ENDPOINT`\": `RESPONSE`} }  E.g.: {   \"result\": {     \"status\": \"ok\",     \"getAutoLendApr\": {       \"apr_usdc\": 8.5,       \"apr_ilk\": 10.9     }   } }  In case of error HTTP status code 422 is returned. In this case the following response body format applies:  {   \"result\": {\"status\": \"error\", \"`ENDPOINT`\": {}},   \"error\": {\"code\": \"`ERROR_CODE`\", \"message\": \"`ERROR_MESSAGE`\"} }  E.g.: {   \"result\": {     \"status\": \"error\",     \"login\": {}   },   \"error\": {     \"code\": \"EGEN_badreq_E001\",     \"message\": \"Bad request or missing field, please check the API documentation\"   } }  The following general error codes are defined: - `EGEN_dbresp_E001`: Internal error. - `EGEN_badreq_E001`: Missing or invalid parameters passed in request body. - `EGEN_undef_E001`: Unknown error.  In case of authentication error status code 401 is returned with the following body:  {   \"result\": {\"status\": \"error\", \"`ENDPOINT`\": {}},   \"error\": {\"code\": \"EGEN_unauth_E001\", \"message\": \"Unauthorized access\"} }  # Authentication (valid only for retail endpoints) This API offers an APIKey + Signed with Secret Key based authentication.  All gateway API requests must include the proper authentication headers:  Every API call has a SHA-512 HMAC signature generated with partner's secret key.  Gateway backend generates it's own HMAC signature and compares it with the partner.  Unauthorized access status returns if both hash don't match.  The HMAC signature is sent as a HTTP header called 'X-Signature'.  Also mandatory for all API calls is the partner's APIKey in the HTTP header called 'X-Apikey'.  POST data signature remark: When request contains POST data, is should be serialized json without  whitespaces. Signature calculated based on this raw string: concat(full url + sha256(serialized json post data))  Example code to create/check a signature in python:  ``` def reproduce_signature(secret):     raw_data = str(request.url+serialized_data()).encode('utf-8')     raw_secret = base58.b58decode(secret)     raw_check = hmac.new(raw_secret, raw_data, hashlib.sha512)     check = base58.b58encode(raw_check.digest())     return check.decode('utf-8')   def serialized_data():     if not request.is_json:         return ''     # most compact format of a json, without any whitespace     return json.dumps(request.json, indent=None, separators=(',', ':')) ```  <SecurityDefinitions /> 
 *
 * API version: 1.4.5
 * Generated by: Swagger Codegen (https://github.com/swagger-api/swagger-codegen.git)
 */
package swagger

import (
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
)

// Linger please
var (
	_ context.Context
)

type WithdrawApiService service
/*
WithdrawApiService Requests a new withdrawal from user balance.:tag withdraw
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
@return StartWithdrawResp
*/
func (a *WithdrawApiService) RetailStartWithdrawPost(ctx context.Context, body RetailStartWithdrawBody) (StartWithdrawResp, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue StartWithdrawResp
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/retail/startWithdraw"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v StartWithdrawResp
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		if localVarHttpResponse.StatusCode == 422 {
			var v GeneralErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
